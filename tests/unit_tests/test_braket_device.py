import json
from unittest import mock
from unittest.mock import Mock, patch

import numpy as np
import pennylane as qml
import pytest
from braket.aws import AwsQpuArns, AwsQuantumSimulatorArns, AwsQuantumTask
from braket.circuits import Circuit
from braket.tasks import GateModelQuantumTaskResult
from pennylane_braket import AWSIonQDevice, AWSRigettiDevice, AWSSimulatorDevice

RESULT = GateModelQuantumTaskResult.from_string(
    json.dumps(
        {
            "Measurements": [[0, 0], [1, 1], [1, 1], [1, 1]],
            "TaskMetadata": {
                "Id": "UUID_blah_1",
                "Status": "COMPLETED",
                "CwLogGroupArn": "blah",
                "Program": "....",
            },
        }
    )
)
BELL_STATE = Circuit().i(0).i(1).h(0).cnot(0, 1)


def test_reset():
    """ Tests that the members of the device are cleared on reset.
    """
    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    dev.circuit = BELL_STATE
    dev.result = RESULT

    dev.reset()
    assert dev.circuit is None
    assert dev.result is None


def test_apply():
    """ Tests that the device's circuit member is set after apply is called.
    """
    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    operations = [qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1]), qml.RX(np.pi/2, wires=1)]
    rotations = [qml.RY(np.pi, wires=0)]
    dev.apply(operations, rotations)

    assert dev.circuit == Circuit().i(0).i(1).h(0).cnot(0, 1).rx(1, np.pi/2).ry(0, np.pi)


@pytest.mark.xfail(raises=NotImplementedError)
def test_apply_unsupported():
    """ Tests that apply() throws NotImplementedError when it encounters an unknown gate.
    """
    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    mock_op = Mock()
    mock_op.name = "foo"

    operations = [qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1]), mock_op]
    dev.apply(operations)


# The next five tests ensure that for all of the Braket devices, the samples
# generated by generate_samples match those in the results
# and AwsQuantumTask.create is called with the right arguments.

@patch.object(AwsQuantumTask, "create")
def test_generate_samples_ionq(mock_create):
    task = Mock()
    task.result.return_value = RESULT
    mock_create.return_value = task
    dev = AWSIonQDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    dev.apply([qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1])])

    assert (dev.generate_samples() == RESULT.measurements).all()
    mock_create.assert_called_with(
        mock.ANY,
        AwsQpuArns.IONQ,
        BELL_STATE,
        ("foo", "bar"),
        10000,
        poll_timeout_seconds=3600
    )


@patch.object(AwsQuantumTask, "create")
def test_generate_samples_rigetti(mock_create):
    task = Mock()
    task.result.return_value = RESULT
    mock_create.return_value = task

    dev = AWSRigettiDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    dev.apply([qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1])])

    assert (dev.generate_samples() == RESULT.measurements).all()
    mock_create.assert_called_with(
        mock.ANY,
        AwsQpuArns.RIGETTI,
        BELL_STATE,
        ("foo", "bar"),
        10000,
        poll_timeout_seconds=3600
    )


@patch.object(AwsQuantumTask, "create")
def test_generate_samples_qs1(mock_create):
    task = Mock()
    task.result.return_value = RESULT
    mock_create.return_value = task

    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
        backend="QS1"
    )
    dev.apply([qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1])])

    assert (dev.generate_samples() == RESULT.measurements).all()
    mock_create.assert_called_with(
        mock.ANY,
        AwsQuantumSimulatorArns.QS1,
        BELL_STATE,
        ("foo", "bar"),
        10000,
        poll_timeout_seconds=120
    )


@patch.object(AwsQuantumTask, "create")
def test_generate_samples_qs2(mock_create):
    task = Mock()
    task.result.return_value = RESULT
    mock_create.return_value = task

    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
        backend="QS2"
    )
    dev.apply([qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1])])

    assert (dev.generate_samples() == RESULT.measurements).all()
    mock_create.assert_called_with(
        mock.ANY,
        AwsQuantumSimulatorArns.QS2,
        BELL_STATE,
        ("foo", "bar"),
        10000,
        poll_timeout_seconds=120
    )


@patch.object(AwsQuantumTask, "create")
def test_generate_samples_qs3(mock_create):
    task = Mock()
    task.result.return_value = RESULT
    mock_create.return_value = task

    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    dev.apply([qml.Hadamard(wires=0), qml.CNOT(wires=[0, 1])])

    assert (dev.generate_samples() == RESULT.measurements).all()
    mock_create.assert_called_with(
        mock.ANY,
        AwsQuantumSimulatorArns.QS3,
        BELL_STATE,
        ("foo", "bar"),
        10000,
        poll_timeout_seconds=120
    )


def test_probability():
    """ Tests that the right probabilities are passed into marginal_prob.
    """
    dev = AWSSimulatorDevice(
        wires=2,
        s3_destination_folder=("foo", "bar"),
        shots=10000,
    )
    dev.result = RESULT
    probs = np.array([0.25, 0, 0, 0.75])
    assert (dev.probability() == dev.marginal_prob(probs)).all()
